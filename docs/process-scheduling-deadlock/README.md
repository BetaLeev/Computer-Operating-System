# 进程调度与死锁

## 第一节 进程调度的功能与时机

一、进程调度的功能

进程调度功能是由操作系统内核的进程调度程序完成，在Linux内核中，进程调度功能的实现从调用内核函数schedule()开始。进程调度的功能是按照某种策略和算法从就绪态进程中为当前空闲的CPU选择在其上运行的新进程。

二、进程调度的时机

当一个进程运行结束（包括正常结合和异常结束）、进程阻塞、中断返回、在支持抢占式系调度的系统中有比当前运行进程优先级更高的进程到来、当前运行进程的时间片用完是后，系统都会通过执行进程调度程序重新进行进程调度。

## 第二节 进程调度算法

进程调度算法是指从就绪态进程中选择一个或几个进程为其分配CPU，使其进入执行态的算法。也就是说进程调度算法要“决定”把CPU分配给就绪队列中的哪个进程。进程调度由操作系统内核中的进程调度程序完成。

一、选择调度方式和算法的若干准则

1. 周转时间短
周转时间是值从作业被提交给系统开始，到作业完成为止的这段时间间隔。它包括4部分时间：作业在外存后背队列上等待调度的时间，进程在就绪队列上等待进程调度的时间，进程在CPU上执行的时间，以及进程等待I/O操作完成的时间。

对每个用户而言，都希望自己的作业周转时间尽可能短。而计算机系统的设计者和管理者使用平均周转时间和带权平均周转时间来衡量系统的时间性能。

2. 响应时间快
响应时间是指从用户提交一个请求开始直至系统首次产生影响的时间为止的一段时间，它包括3部分时间：从输入设备输入的请求信息传送到处理机的时间、处理机对请求信息进行处理的时间，以及将所形成的响应信息回送到终端显示器的时间。对于交互式系统，响应时间是衡量系统时间性能的重要指标。进程调度算法和输入/输出设备的速度都会影响系统的响应时间。

3. 截止时间的保证
截止时间是指某个任务必须开始执行的最迟时间，或必须完成的最迟时间。
截止时间是评价实时系统性能的重要指标。在实时系统中，若实时任务的开始截止时间或完成截止时间不能得到保障，实时系统的可靠性就无法保证。因为实时系统计算的正确性不仅取决于计算的逻辑结果的正确性，而且取决于得到计算结果的时间。实时系统必须采取特殊的调度策略和调度算法来满足对截止时间的要求。

4. 系统吞吐量高
吞吐量是指单位时间内完成的作业数。
系统的吞吐量是评价系统性能的重要指标之一，调度算法影响系统的吞吐量。

5. 处理机利用率好
CPU是计算机系统中影响时间性能的 最重要的硬件资源，在多任务系统中，进程调度算法对CPU的利用率有很大影响。因此，在选择和设计进程调度算法时应考虑使CPU的利用率尽可能高。

二、调度算法

1. 先来先去服务调度算法
(1) 调度算法
在进程调度中，FCFS就是从就绪队列的队首选择最先到达就绪队列的进程，为该进程分配CPU。
(2) 性能分析
FCFS适合长进程，不利于短进程，短进程等待时间相对运行时间而言太长。
FCFS使短进程的周转时间过长，系统的平均周转时间也比较长。
FCFS有利于CPU繁忙型进程，不利于I/O繁忙型进程。

2. 短进程优先调度算法
(1) 调度算法
短进程优先（SPF）的调度算法是从就绪队列中选择估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行完成，或发生某事件而被阻塞放弃处理机时，再重新调度。

(2) 算法优点
与FCFS算法相比，短进程优先的算法能有效降低进程的平均等待时间，提高系统的吞吐量。

(3) 算法缺陷
1) 对长进程不利。如果系统中不断有短进程到来，长进程可能长时间得不到调度。
2) 不能保证紧迫进程的及时处理，因为该算法不考虑进程的紧迫程度。
3) 进程的长短根据用户的估计而定，故不一定能真正做到短进程优先。

3. 优先权调度算法
(1) 调度算法
(2) 优先权调度算法的类型
(3) 优先权的类型

4. 时间片轮转调度算法
(1) 时间片轮转调度算法
(2) 时间片大小的确定
(3) 时间片轮转调度算法的性能评价

5. 多级队列调度
(1) 多级队列调度算法

6. 多级反馈队列调度
一旦进程进入系统，就被固定地分配到一个就绪队列中，进程在被撤销前不会在不同队列之间移动。这种算法的优点是降低了进程调度的开销，但是不够灵活，对低优先权进程会存在无穷阻塞问题。
而多级反馈队列调度可以弥补这些不足。

## 第三节 实时系统中的调度

一、实现实时系统调度的基本条件
为了满足实时系统对截止时间的要求，实现实时系统调度应具备下列几个条件

1. 提供必要的调度信息
1) 就绪时间。 是一个实时任务成为就绪态的起始时间
2) 开始截止时间和完成截止时间
3) 处理时间 指一个实时任务从开始执行直至完成所需要的时间
4) 资源要求 关于任务执行所需要的资源信息
5) 优先级 根据实时任务紧迫程度的不同，可以给实时任务赋予不同的优先权，使高优先权任务能优先获得系统资源，尽快得到执行。 系统中实时进程的优先权不能动态降低。

2. 系统处理能力强
在实时系统中，通常有多个实时进程，若处理机的处理能力不够强，处理速度不够快，从而使某些实时进程不能的得到及时处理，可能发生难以预料的后果。
1) 单处理机情况下必须满足的限制条件
2) n个处理机情况下必须满足的限制条件

3. 采用抢占式调度机制
在实时系统中广泛采用抢占式调度。
当一个优先权更高的进程到达时，允许将当前进程暂时挂起，而令高优先权进程立即投入运行。
这样可以满足实时进程对截止时间的要求。
为了使调度过程更简单，调度开销更小，对于支持需要服务时间很短的小实时进程的系统，也可以采用非抢占式调度。
抢占式调度算法根据抢占CPU的时机不同，可以分为基于时钟中断的抢占式和立即抢占。
1) 基于时钟中断的抢占式优先权调度算法
2) 立即抢占的优先权调度算法

4. 具有快速切换机制
为保证对截止时间要求较高的实时进程能及时运行，在实时系统中还应具有快速切换机制，以保证进程的快速切换。该机制应具有以下两个方面的能力。
1) 对外部中断的快速响应能力
为使在紧迫的外部事件请求中断时系统能及时响应，要求系统具有快速的硬件中断机构，还应使禁止中断的时间间隔尽可能短。

2) 快速的进程切换能力
在完成进程调度后进行进程切换。为了提高进程切换时的速度，应使系统中的每个运行功能单位适当地小，以减少进程切换的时间开销。

二、常用的几种实时调度算法
1. 最早截止时间优先 (EDF)

2. 最低松弛度优先 (LLF)

## 第四节 进程切换
当进程调度程序选择到一个新的进程后，要进程进程切换，用新选择的进程替换原来的执行进程，也就是把CPU的控制权交给由调度程序所选择的进程。
进程切换使当前正在执行的进程成为被替换过程，让出其所使用的CPU，以运行被进程调度程序选中的新进程。进程切换通常包括一下几个步骤。

1) 保存包括程序计数器和其他寄存器在内的CPU上下文环境。
2) 更新被替换进程的进程控制块。
3) 修改进程状态，把执行态改为就绪态或阻塞态。
4) 将被替换进程的进程控制块移到就绪队列或阻塞队列。
5) 执行通过进程调度程序选择的新进程，并更新该进程的进程控制块。
6) 更新内存管理的数据结构。
7) 恢复被调度程序选中的进程的硬件上下文。

## 第五节 多处理器调度

一、多处理器系统
1. 紧密耦合的多处理器系统和松弛耦合的多处理器系统
(1) 紧密耦合的多处理器系统
(2) 松弛耦合的多处理器系统

2. 对称多处理器系统和非对称多处理器系统
对称多处理器系统属于同构的多处理器系统，其中所包含的各处理单元，在功能和结构上都是相同的，当前的绝大多数多处理器系统都是对称多处理器系统。
非对称多处理器系统中有多种类型的处理单元，它们的功能和结构各不相同。其中只有一个主处理器，有多个从处理器。

二、 多处理器系统中的进程分配方式

1. 对称多处理器系统中的进程分配方式
(1) 静态分配
(2) 动态分配

2. 非对称多处理器系统中的进程分配方式
对于非对称多处理器系统，大多采用主 - 从式操作系统，即操作系统的核心部分驻留在一台主机上，而从机上只运行用户程序，只有主机执行调度程序，所有从机的进程都是由主机分配的。每当从机空闲时，便向主机发送一个请求分配进程的信号，然后便等待主机为它分配进程。在主机中保持有一个就绪队列，只要就绪队列不为空，主机便从其队首摘下一个进程分配给请求分配进程的从机。从机接收到分配的进程后便运行该进程，该进程结束后从机又向主机发送请求。

三、进程（线程）调度方式
1. 自调度
自调度算法是当前多处理器系统中最常用的调度方式之一，也是最简单的一种调度方式。采用自调度的系统中设置一个公共的就绪队列，任何一个空闲的处理器都可以自从该就绪队列中选取一个进程或者一个线程运行。在自调度方式中，可采用在单处理器环境下所有的调度算法，如先来先服务调度算法，最高优先权调度算法等。
在多处理器环境下，FCFS是一种较好的自调度算法，算法简单，开销小。
1) 自调度算法的优点
(1) 易移植。
在采用自调度方式的系统中，公共就绪队列可按照单处理器系统中采用的各种组织方式加以组织，其调度算法也可沿用单处理器系统所用的算法，因此，很容易将但处理器环境下的调度机制移植到多处理器系统中。

(2) 有利于提高CPU的利用率。只要系统中又任务，或者说只要公共就绪队列不为空，就不会出现处理器空闲的情况，也不会发生处理器忙闲不均的现象，因而有利于提高处理器的利用率。

2) 自调度方式的缺点
(1) 瓶颈问题
(2) 低效性
(3) 线程切换频繁

2. 成组调度
成组调度方式是由系统将一组相互合作的线程或进程同时分配到一组处理器上运行，进程或线程与处理器一一对应。
1) 成组调度的优点
(1) 减少线程切换，改善系统系统。 如果一组相互合作的线程或进程能并行执行，则能有效减少进程(线程)阻塞情况的发生，从而减少线程的切换，使系统性能得到改善。

(2) 减少调度开销。因为每次调度都可以解决一组线程的处理器分配问题，因而可以显著减少调度频率，从而减少调度开销。
2) 成组调度中的时间分配
在成组调度中可以采用两种方式为应用程序分配处理器时间：一是面向所有的应用程序平均分配处理器时间； 二是面向所有线程平均分配处理器时间。

3. 专用处理器分配
该方式是在一个应用程序执行期间，专门为该应用程序分配一组处理器，每个线程一个，这组处理器供该应用程序专用，直至应用程序完成。
这种方式会造成处理器资源的严重浪费。因为当一个处理器上的线程被阻塞时，处理器不能分配给别的线程使用，只能空等。
之所以可以将这种专门处理器调度方式用于并发程序高的多的处理器环境，是因为在具有数十个乃至上百个处理器的并行系统中，每个处理器的投资费用在整个系统中仅占很小的比重。对整个系统的性能和效率而言，单个处理器的使用效率并不像在单处理器系统中那么重要。其次，在一个应用程序的整个运行过程中，由于每个进程或线程专用一台处理器，因此可以完全避免进程或线程的切换，从而可以大大加速程序的完成。
总的来说，专用处理器的优点一是加速了应用程序的运行速度，二是避免了程序切换。

## 第六节 死锁

一、产生死锁的原因和必要条件
在多道程序系统中，多个进程可能竞争数量有限的资源。如果一个进程所申请的资源被其他处于阻塞状态的进程占有，该进程就会因为不能获得所申请的资源而被阻塞。
若此时该进程恰好又占有了前述其他进程所需要的资源，那么这一组进程就可能因为等待释放自己所需要但被其他进程已占有的资源而无法向前推进。这种由于多个进程竞争共享资源而引起的进程不能向前推进的僵死状态成为死锁。

1. 产生死锁的原因
进程访问资源是通过执行程序实现的。
一般来说，进程按照申请资源、访问资源和释放资源的顺序使用资源。
产生死锁的原因为:竞争共享资源且分配资源的顺序不当。

2. 产生死锁的必要条件
死锁产生时，必须同时满足下列4个条件。
(1) 互斥条件
 指一个进程在访问资源的过程中，其他进程不能访问该资源。
 如果一个资源正在被访问时，有其他进程也提出对该资源的访问请求，必须把请求该资源的进程阻塞起来，直到资源被进程释放。

(2) 请求和保持条件
进程已经保持了至少一个资源，又提出了新的资源请求，而新请求的资源已经被其他进程占有，此时进程阻塞，但又对已经获得的资源保持不放，使得其他进程无法使用被保持的资源。

(3) 不剥夺条件
进程已经获得的资源不能被剥夺，只能由进程自己释放。

(4) 环路等待条件
发生死锁时，必然存在一个进程申请资源的唤醒链。

二、处理死锁的基本方法

1. 死锁的预防
死锁预防是根据前面讨论的死锁必要条件，通过保证至少其中一个条件不成立来达到预防发生死锁的目的。
预防死锁可以通过摒弃下列三个必要条件之一来实现。
1) 摒弃请求和保持条件
2) 摒弃不剥夺条件
3) 摒弃环路等待条件

2. 死锁的避免
避免死锁的方法是把系统的资源分配状态分成安全状态和不安全状态，只要资源分配使系统资源分配状态处于安全状态，死锁就不会发生。
在避免死锁的方法中，允许进程动态地申请资源。
系统在资源分配之前，先计算资源分配的安全性。若本次资源分配不会导致系统进入不安全状态，便将系统分配给进程。
否则拒绝进程的资源请求，将进程阻塞起来。
1) 系统的安全状态
当系统能找到一个进程执行序列，使系统只要按此序列为每个进程分配资源，就可以保证进程的资源分配和执行顺利完成，不会发生死锁，称系统处于安全状态。若系统不存在这样的安全序列，则称系统处于不安全状态。

2) 安全状态举例


三、银行家算法

1. 数据结构

2. 银行家算法的说明

四、死锁的检测和解除
操作系统可以不采取事先预防和避免的方法来解决死锁问题，而是检测是否有死锁发生，如果检测到系统中有死锁进程，则解决死锁。

1. 何时调用检测算法
一是死锁可能发生的频率，二是当死锁发生时受影响的进程数量。

2. 资源分配图


3. 死锁定理
死锁定理用于检测系统所处的资源分配状态S是否为死锁状态。
死锁定理为：S为死锁状态的充分条件是当且仅当S状态的资源分配图是不可完全简化的。

4. 死锁的解除
检测到系统出现死锁后，可以由系统管理员人工处理死锁，也可以让系统自动解除死锁。
检测死锁的途径有两个：一是终止处于死锁状态的进程，二是抢占死锁进程占有的资源。
(1) 进程终止 
终止死锁的进程后，系统回收进程占有的资源。可以采用下面两种方式终止进程。
1) 终止所有死锁进程。
2) 一次只终止一个处于死锁的进程，直到死锁解除。

(2) 资源抢占
逐步从进程中抢占资源给其他进程使用，直到死锁环被打破为止。
如果要求使用抢占来处理死锁，那么有3个问题需要处理。

1) 抢占哪个进程和哪些资源？
必须确定抢占的顺序以使代价最小。
影响因素有:死锁进程所拥有的资源数量、死锁进程到目前为止已经消耗的执行时间等。

2) 回滚。
如果从一个进程那里抢占一个资源，那么该进程因缺少资源不能从抢占点正常执行，必须将进程回滚到某个安全状态，以便从该状态重启进程。
最简单的方法是完全回滚，就是终止进程并重启进程。

3) 饥饿。
饥饿是进程因长时间不能获得所需要的资源而无限等待的状态。
比如系统采取基于静态优先权的进程调度算法，当系统不断有高优先权进程到来时，优先权低的进程就可能长时间得不到CPU，也就不能运行，
这种状态被称为饥饿状态。
处于饥饿状态的进程不影响其他进程获得资源，死锁的进程与饥饿进程一样无法继续获得资源。但是死锁一旦发生，便涉及竞争资源的一组进程。系统中不会出现单个进程死锁的现象。但是可能会只有一个进程饥饿。
在抢占资源的过程中如何保证不会总从同一个进程抢占资源而使该进程处于饥饿状态？
一个解决方案是限制对同一进程进行抢占资源的次数。
最常与哦你给的方法是影响代价的因素中加上回滚次数。
